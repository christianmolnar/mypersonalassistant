// Robot Fleet Metrics System - Following Design Document Specifications
// File: lib/robot-fleet-metrics.ts

import { register, Counter, Histogram, Gauge, Summary } from 'prom-client';

// ===================================================================
// ROBOT FLEET STATUS METRICS (Following Design Document)
// ===================================================================

// Fleet Overview Metrics
export const robotFleetTotal = new Gauge({
  name: 'robot_fleet_total',
  help: 'Total deployable robot capacity',
  labelNames: ['robot_type'], // image_generator, vinyl_researcher, communications, memorias_ai, fact_checker, finsight_ai
});

export const robotFleetHealthy = new Gauge({
  name: 'robot_fleet_healthy',
  help: 'Number of healthy robots by type',
  labelNames: ['robot_type'],
});

export const robotFleetDegraded = new Gauge({
  name: 'robot_fleet_degraded', 
  help: 'Number of degraded robots by type',
  labelNames: ['robot_type'],
});

export const robotFleetCritical = new Gauge({
  name: 'robot_fleet_critical',
  help: 'Number of critical robots by type', 
  labelNames: ['robot_type'],
});

export const robotFleetDown = new Gauge({
  name: 'robot_fleet_down',
  help: 'Number of down robots by type',
  labelNames: ['robot_type'],
});

// ===================================================================
// ROBOT CLASS SUCCESS RATES (Row 2)
// ===================================================================

export const robotSuccessRate = new Gauge({
  name: 'robot_success_rate_percent',
  help: 'Success rate percentage for each robot type business function',
  labelNames: ['robot_type', 'function_type'], // function_type: image_generation, research_query, message_delivery, etc.
});

export const robotTransactionsTotal = new Counter({
  name: 'robot_transactions_total',
  help: 'Total completed transactions by robot type',
  labelNames: ['robot_type', 'status'], // status: success, failure
});

// ===================================================================
// ROBOT ACTIVITY THROUGHPUT (Row 3)
// ===================================================================

export const robotThroughputRate = new Gauge({
  name: 'robot_throughput_transactions_per_minute',
  help: 'Current throughput rate in transactions per minute',
  labelNames: ['robot_type'],
});

export const robotThroughputBaseline = new Gauge({
  name: 'robot_throughput_baseline_transactions_per_minute',
  help: 'Baseline throughput rate for comparison',
  labelNames: ['robot_type'],
});

export const robotTransactionDuration = new Histogram({
  name: 'robot_transaction_duration_seconds',
  help: 'Duration of complete business transactions',
  labelNames: ['robot_type', 'transaction_complexity'], // simple, medium, complex
  buckets: [1, 5, 10, 30, 60, 120, 300, 600],
});

// ===================================================================
// ROBOT RESOURCE UTILIZATION (Row 4)
// ===================================================================

export const robotCpuUtilization = new Gauge({
  name: 'robot_cpu_utilization_percent',
  help: 'CPU utilization percentage by robot type',
  labelNames: ['robot_type'],
});

export const robotMemoryUtilization = new Gauge({
  name: 'robot_memory_utilization_percent', 
  help: 'Memory utilization percentage by robot type',
  labelNames: ['robot_type'],
});

// ===================================================================
// ROBOT-SPECIFIC BUSINESS METRICS
// ===================================================================

// Image Generator Robot
export const imageGenRobotMetrics = {
  promptComplexity: new Histogram({
    name: 'image_gen_robot_prompt_complexity_score',
    help: 'Complexity score of image generation prompts',
    labelNames: ['style_category'],
    buckets: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
  }),
  imageSizeGenerated: new Counter({
    name: 'image_gen_robot_images_by_size_total',
    help: 'Total images generated by size category',
    labelNames: ['size_category'], // small, medium, large, xlarge
  }),
  generationQuality: new Gauge({
    name: 'image_gen_robot_quality_score',
    help: 'Average quality score of generated images',
    labelNames: ['style_category'],
  }),
};

// Vinyl Researcher Robot  
export const vinylResearchRobotMetrics = {
  sourcesAccessed: new Counter({
    name: 'vinyl_research_robot_sources_accessed_total',
    help: 'Number of data sources accessed per research query',
    labelNames: ['source_type'], // discogs, musicbrainz, spotify, bandcamp
  }),
  researchDepth: new Histogram({
    name: 'vinyl_research_robot_depth_score',
    help: 'Depth score of research queries',
    labelNames: ['query_type'],
    buckets: [1, 2, 3, 4, 5],
  }),
  accuracyScore: new Gauge({
    name: 'vinyl_research_robot_accuracy_percent',
    help: 'Research accuracy percentage',
    labelNames: ['research_category'],
  }),
};

// Communications Robot
export const communicationsRobotMetrics = {
  messageVolume: new Counter({
    name: 'communications_robot_messages_total',
    help: 'Total messages processed',
    labelNames: ['message_type', 'direction'], // type: email, chat, sms; direction: inbound, outbound
  }),
  responseTime: new Histogram({
    name: 'communications_robot_response_time_seconds',
    help: 'Response time for communications',
    labelNames: ['urgency_level'],
    buckets: [1, 5, 10, 30, 60, 300, 600],
  }),
  sentimentScore: new Gauge({
    name: 'communications_robot_sentiment_score',
    help: 'Average sentiment score of communications',
    labelNames: ['communication_type'],
  }),
};

// Memorias-AI Robot
export const memoriasRobotMetrics = {
  transcriptionAccuracy: new Gauge({
    name: 'memorias_robot_transcription_accuracy_percent',
    help: 'Transcription accuracy percentage',
    labelNames: ['audio_quality', 'language'],
  }),
  audioProcessingTime: new Histogram({
    name: 'memorias_robot_audio_processing_seconds',
    help: 'Audio processing time by file size',
    labelNames: ['file_size_category'], // small, medium, large
    buckets: [5, 10, 30, 60, 120, 300, 600],
  }),
  memoryStorageEfficiency: new Gauge({
    name: 'memorias_robot_storage_efficiency_ratio',
    help: 'Storage efficiency ratio for processed memories',
    labelNames: ['content_type'],
  }),
};

// Fact Checker Robot
export const factCheckerRobotMetrics = {
  verificationAccuracy: new Gauge({
    name: 'fact_checker_robot_verification_accuracy_percent',
    help: 'Fact verification accuracy percentage',
    labelNames: ['claim_category'],
  }),
  sourcesVerified: new Counter({
    name: 'fact_checker_robot_sources_verified_total',
    help: 'Number of sources verified per fact check',
    labelNames: ['source_reliability'], // high, medium, low
  }),
  confidenceScore: new Histogram({
    name: 'fact_checker_robot_confidence_score',
    help: 'Confidence score distribution for fact checks',
    labelNames: ['verification_method'],
    buckets: [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0],
  }),
};

// F.Insight.AI Robot
export const finsightRobotMetrics = {
  analysisComplexity: new Histogram({
    name: 'finsight_robot_analysis_complexity_score',
    help: 'Complexity score of financial analyses',
    labelNames: ['analysis_type'], // portfolio, risk, trend, prediction
    buckets: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
  }),
  dataPointsProcessed: new Counter({
    name: 'finsight_robot_data_points_processed_total',
    help: 'Number of data points processed in analysis',
    labelNames: ['data_source'],
  }),
  predictionAccuracy: new Gauge({
    name: 'finsight_robot_prediction_accuracy_percent',
    help: 'Accuracy of financial predictions',
    labelNames: ['prediction_type', 'time_horizon'],
  }),
};

// ===================================================================
// ROBOT FLEET INSTRUMENTATION CLASS
// ===================================================================

export class RobotFleetInstrumentation {
  
  // Fleet Status Updates (Row 1)
  static updateFleetStatus(robotType: string, total: number, healthy: number, degraded: number, critical: number, down: number) {
    robotFleetTotal.labels(robotType).set(total);
    robotFleetHealthy.labels(robotType).set(healthy);
    robotFleetDegraded.labels(robotType).set(degraded);
    robotFleetCritical.labels(robotType).set(critical);
    robotFleetDown.labels(robotType).set(down);
  }

  // Success Rate Updates (Row 2)
  static updateSuccessRate(robotType: string, functionType: string, successRate: number) {
    robotSuccessRate.labels(robotType, functionType).set(successRate);
  }

  // Throughput Updates (Row 3)
  static updateThroughput(robotType: string, currentRate: number, baselineRate: number) {
    robotThroughputRate.labels(robotType).set(currentRate);
    robotThroughputBaseline.labels(robotType).set(baselineRate);
  }

  // Resource Utilization Updates (Row 4)
  static updateResourceUtilization(robotType: string, cpuPercent: number, memoryPercent: number) {
    robotCpuUtilization.labels(robotType).set(cpuPercent);
    robotMemoryUtilization.labels(robotType).set(memoryPercent);
  }

  // Transaction Recording
  static recordTransaction(robotType: string, success: boolean, duration: number, complexity: string = 'medium') {
    const status = success ? 'success' : 'failure';
    robotTransactionsTotal.labels(robotType, status).inc();
    robotTransactionDuration.labels(robotType, complexity).observe(duration);
  }

  // Initialize Fleet with Realistic Synthetic Data
  static initializeFleetData() {
    const fleetConfig = [
      { type: 'image_generator', total: 400, baseline: 45, cpuAvg: 65, memAvg: 70 },
      { type: 'vinyl_researcher', total: 150, baseline: 12, cpuAvg: 45, memAvg: 60 },
      { type: 'communications', total: 200, baseline: 85, cpuAvg: 35, memAvg: 50 },
      { type: 'memorias_ai', total: 300, baseline: 35, cpuAvg: 55, memAvg: 65 },
      { type: 'fact_checker', total: 100, baseline: 8, cpuAvg: 40, memAvg: 55 },
      { type: 'finsight_ai', total: 500, baseline: 125, cpuAvg: 50, memAvg: 60 },
    ];

    fleetConfig.forEach(config => {
      // Fleet status - mostly healthy with some realistic degradation
      const healthy = Math.floor(config.total * (0.90 + Math.random() * 0.08)); // 90-98%
      const degraded = Math.floor(config.total * (0.02 + Math.random() * 0.05)); // 2-7%
      const critical = Math.floor(config.total * (0.01 + Math.random() * 0.02)); // 1-3%
      const down = config.total - healthy - degraded - critical;

      this.updateFleetStatus(config.type, config.total, healthy, degraded, critical, down);
      
      // Success rates - high with slight variation
      const successRate = 95 + Math.random() * 4; // 95-99%
      this.updateSuccessRate(config.type, 'primary_function', successRate);
      
      // Throughput - baseline with variation
      const currentThroughput = config.baseline * (0.9 + Math.random() * 0.2); // 90-110% of baseline
      this.updateThroughput(config.type, currentThroughput, config.baseline);
      
      // Resource utilization - realistic levels
      const cpuVariation = config.cpuAvg + (Math.random() - 0.5) * 20; // ±10%
      const memVariation = config.memAvg + (Math.random() - 0.5) * 20; // ±10%
      this.updateResourceUtilization(config.type, Math.max(0, Math.min(100, cpuVariation)), Math.max(0, Math.min(100, memVariation)));
    });
  }
}

export { register };
